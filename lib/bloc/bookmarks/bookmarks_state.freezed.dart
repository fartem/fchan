// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'bookmarks_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$BookmarksStateTearOff {
  const _$BookmarksStateTearOff();

  BookmarksInitial bookmarksInitial() {
    return const BookmarksInitial();
  }

  BookmarksLoadSuccess bookmarksLoadSuccess({required List<Thread> threads, required bool isLastPage}) {
    return BookmarksLoadSuccess(
      threads: threads,
      isLastPage: isLastPage,
    );
  }

  BookmarksLoadError bookmarksLoadError() {
    return const BookmarksLoadError();
  }

  BookmarksClearInProgress bookmarksClearInProgress() {
    return const BookmarksClearInProgress();
  }

  BookmarksIsEmpty bookmarksIsEmpty() {
    return const BookmarksIsEmpty();
  }
}

/// @nodoc
const $BookmarksState = _$BookmarksStateTearOff();

/// @nodoc
mixin _$BookmarksState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bookmarksInitial,
    required TResult Function(List<Thread> threads, bool isLastPage) bookmarksLoadSuccess,
    required TResult Function() bookmarksLoadError,
    required TResult Function() bookmarksClearInProgress,
    required TResult Function() bookmarksIsEmpty,
  }) =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bookmarksInitial,
    TResult Function(List<Thread> threads, bool isLastPage)? bookmarksLoadSuccess,
    TResult Function()? bookmarksLoadError,
    TResult Function()? bookmarksClearInProgress,
    TResult Function()? bookmarksIsEmpty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookmarksInitial value) bookmarksInitial,
    required TResult Function(BookmarksLoadSuccess value) bookmarksLoadSuccess,
    required TResult Function(BookmarksLoadError value) bookmarksLoadError,
    required TResult Function(BookmarksClearInProgress value) bookmarksClearInProgress,
    required TResult Function(BookmarksIsEmpty value) bookmarksIsEmpty,
  }) =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookmarksInitial value)? bookmarksInitial,
    TResult Function(BookmarksLoadSuccess value)? bookmarksLoadSuccess,
    TResult Function(BookmarksLoadError value)? bookmarksLoadError,
    TResult Function(BookmarksClearInProgress value)? bookmarksClearInProgress,
    TResult Function(BookmarksIsEmpty value)? bookmarksIsEmpty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookmarksStateCopyWith<$Res> {
  factory $BookmarksStateCopyWith(BookmarksState value, $Res Function(BookmarksState) then) =
      _$BookmarksStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$BookmarksStateCopyWithImpl<$Res> implements $BookmarksStateCopyWith<$Res> {
  _$BookmarksStateCopyWithImpl(this._value, this._then);

  final BookmarksState _value;

  // ignore: unused_field
  final $Res Function(BookmarksState) _then;
}

/// @nodoc
abstract class $BookmarksInitialCopyWith<$Res> {
  factory $BookmarksInitialCopyWith(BookmarksInitial value, $Res Function(BookmarksInitial) then) =
      _$BookmarksInitialCopyWithImpl<$Res>;
}

/// @nodoc
class _$BookmarksInitialCopyWithImpl<$Res> extends _$BookmarksStateCopyWithImpl<$Res>
    implements $BookmarksInitialCopyWith<$Res> {
  _$BookmarksInitialCopyWithImpl(BookmarksInitial _value, $Res Function(BookmarksInitial) _then)
      : super(_value, (v) => _then(v as BookmarksInitial));

  @override
  BookmarksInitial get _value => super._value as BookmarksInitial;
}

/// @nodoc
class _$BookmarksInitial implements BookmarksInitial {
  const _$BookmarksInitial();

  @override
  String toString() {
    return 'BookmarksState.bookmarksInitial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is BookmarksInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bookmarksInitial,
    required TResult Function(List<Thread> threads, bool isLastPage) bookmarksLoadSuccess,
    required TResult Function() bookmarksLoadError,
    required TResult Function() bookmarksClearInProgress,
    required TResult Function() bookmarksIsEmpty,
  }) {
    return bookmarksInitial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bookmarksInitial,
    TResult Function(List<Thread> threads, bool isLastPage)? bookmarksLoadSuccess,
    TResult Function()? bookmarksLoadError,
    TResult Function()? bookmarksClearInProgress,
    TResult Function()? bookmarksIsEmpty,
    required TResult orElse(),
  }) {
    if (bookmarksInitial != null) {
      return bookmarksInitial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookmarksInitial value) bookmarksInitial,
    required TResult Function(BookmarksLoadSuccess value) bookmarksLoadSuccess,
    required TResult Function(BookmarksLoadError value) bookmarksLoadError,
    required TResult Function(BookmarksClearInProgress value) bookmarksClearInProgress,
    required TResult Function(BookmarksIsEmpty value) bookmarksIsEmpty,
  }) {
    return bookmarksInitial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookmarksInitial value)? bookmarksInitial,
    TResult Function(BookmarksLoadSuccess value)? bookmarksLoadSuccess,
    TResult Function(BookmarksLoadError value)? bookmarksLoadError,
    TResult Function(BookmarksClearInProgress value)? bookmarksClearInProgress,
    TResult Function(BookmarksIsEmpty value)? bookmarksIsEmpty,
    required TResult orElse(),
  }) {
    if (bookmarksInitial != null) {
      return bookmarksInitial(this);
    }
    return orElse();
  }
}

abstract class BookmarksInitial implements BookmarksState {
  const factory BookmarksInitial() = _$BookmarksInitial;
}

/// @nodoc
abstract class $BookmarksLoadSuccessCopyWith<$Res> {
  factory $BookmarksLoadSuccessCopyWith(BookmarksLoadSuccess value, $Res Function(BookmarksLoadSuccess) then) =
      _$BookmarksLoadSuccessCopyWithImpl<$Res>;

  $Res call({List<Thread> threads, bool isLastPage});
}

/// @nodoc
class _$BookmarksLoadSuccessCopyWithImpl<$Res> extends _$BookmarksStateCopyWithImpl<$Res>
    implements $BookmarksLoadSuccessCopyWith<$Res> {
  _$BookmarksLoadSuccessCopyWithImpl(BookmarksLoadSuccess _value, $Res Function(BookmarksLoadSuccess) _then)
      : super(_value, (v) => _then(v as BookmarksLoadSuccess));

  @override
  BookmarksLoadSuccess get _value => super._value as BookmarksLoadSuccess;

  @override
  $Res call({
    Object? threads = freezed,
    Object? isLastPage = freezed,
  }) {
    return _then(BookmarksLoadSuccess(
      threads: threads == freezed
          ? _value.threads
          : threads // ignore: cast_nullable_to_non_nullable
              as List<Thread>,
      isLastPage: isLastPage == freezed
          ? _value.isLastPage
          : isLastPage // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
class _$BookmarksLoadSuccess implements BookmarksLoadSuccess {
  const _$BookmarksLoadSuccess({required this.threads, required this.isLastPage});

  @override
  final List<Thread> threads;
  @override
  final bool isLastPage;

  @override
  String toString() {
    return 'BookmarksState.bookmarksLoadSuccess(threads: $threads, isLastPage: $isLastPage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BookmarksLoadSuccess &&
            (identical(other.threads, threads) || const DeepCollectionEquality().equals(other.threads, threads)) &&
            (identical(other.isLastPage, isLastPage) ||
                const DeepCollectionEquality().equals(other.isLastPage, isLastPage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(threads) ^
      const DeepCollectionEquality().hash(isLastPage);

  @JsonKey(ignore: true)
  @override
  $BookmarksLoadSuccessCopyWith<BookmarksLoadSuccess> get copyWith =>
      _$BookmarksLoadSuccessCopyWithImpl<BookmarksLoadSuccess>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bookmarksInitial,
    required TResult Function(List<Thread> threads, bool isLastPage) bookmarksLoadSuccess,
    required TResult Function() bookmarksLoadError,
    required TResult Function() bookmarksClearInProgress,
    required TResult Function() bookmarksIsEmpty,
  }) {
    return bookmarksLoadSuccess(threads, isLastPage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bookmarksInitial,
    TResult Function(List<Thread> threads, bool isLastPage)? bookmarksLoadSuccess,
    TResult Function()? bookmarksLoadError,
    TResult Function()? bookmarksClearInProgress,
    TResult Function()? bookmarksIsEmpty,
    required TResult orElse(),
  }) {
    if (bookmarksLoadSuccess != null) {
      return bookmarksLoadSuccess(threads, isLastPage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookmarksInitial value) bookmarksInitial,
    required TResult Function(BookmarksLoadSuccess value) bookmarksLoadSuccess,
    required TResult Function(BookmarksLoadError value) bookmarksLoadError,
    required TResult Function(BookmarksClearInProgress value) bookmarksClearInProgress,
    required TResult Function(BookmarksIsEmpty value) bookmarksIsEmpty,
  }) {
    return bookmarksLoadSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookmarksInitial value)? bookmarksInitial,
    TResult Function(BookmarksLoadSuccess value)? bookmarksLoadSuccess,
    TResult Function(BookmarksLoadError value)? bookmarksLoadError,
    TResult Function(BookmarksClearInProgress value)? bookmarksClearInProgress,
    TResult Function(BookmarksIsEmpty value)? bookmarksIsEmpty,
    required TResult orElse(),
  }) {
    if (bookmarksLoadSuccess != null) {
      return bookmarksLoadSuccess(this);
    }
    return orElse();
  }
}

abstract class BookmarksLoadSuccess implements BookmarksState {
  const factory BookmarksLoadSuccess({required List<Thread> threads, required bool isLastPage}) =
      _$BookmarksLoadSuccess;

  List<Thread> get threads => throw _privateConstructorUsedError;

  bool get isLastPage => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BookmarksLoadSuccessCopyWith<BookmarksLoadSuccess> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookmarksLoadErrorCopyWith<$Res> {
  factory $BookmarksLoadErrorCopyWith(BookmarksLoadError value, $Res Function(BookmarksLoadError) then) =
      _$BookmarksLoadErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$BookmarksLoadErrorCopyWithImpl<$Res> extends _$BookmarksStateCopyWithImpl<$Res>
    implements $BookmarksLoadErrorCopyWith<$Res> {
  _$BookmarksLoadErrorCopyWithImpl(BookmarksLoadError _value, $Res Function(BookmarksLoadError) _then)
      : super(_value, (v) => _then(v as BookmarksLoadError));

  @override
  BookmarksLoadError get _value => super._value as BookmarksLoadError;
}

/// @nodoc
class _$BookmarksLoadError implements BookmarksLoadError {
  const _$BookmarksLoadError();

  @override
  String toString() {
    return 'BookmarksState.bookmarksLoadError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is BookmarksLoadError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bookmarksInitial,
    required TResult Function(List<Thread> threads, bool isLastPage) bookmarksLoadSuccess,
    required TResult Function() bookmarksLoadError,
    required TResult Function() bookmarksClearInProgress,
    required TResult Function() bookmarksIsEmpty,
  }) {
    return bookmarksLoadError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bookmarksInitial,
    TResult Function(List<Thread> threads, bool isLastPage)? bookmarksLoadSuccess,
    TResult Function()? bookmarksLoadError,
    TResult Function()? bookmarksClearInProgress,
    TResult Function()? bookmarksIsEmpty,
    required TResult orElse(),
  }) {
    if (bookmarksLoadError != null) {
      return bookmarksLoadError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookmarksInitial value) bookmarksInitial,
    required TResult Function(BookmarksLoadSuccess value) bookmarksLoadSuccess,
    required TResult Function(BookmarksLoadError value) bookmarksLoadError,
    required TResult Function(BookmarksClearInProgress value) bookmarksClearInProgress,
    required TResult Function(BookmarksIsEmpty value) bookmarksIsEmpty,
  }) {
    return bookmarksLoadError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookmarksInitial value)? bookmarksInitial,
    TResult Function(BookmarksLoadSuccess value)? bookmarksLoadSuccess,
    TResult Function(BookmarksLoadError value)? bookmarksLoadError,
    TResult Function(BookmarksClearInProgress value)? bookmarksClearInProgress,
    TResult Function(BookmarksIsEmpty value)? bookmarksIsEmpty,
    required TResult orElse(),
  }) {
    if (bookmarksLoadError != null) {
      return bookmarksLoadError(this);
    }
    return orElse();
  }
}

abstract class BookmarksLoadError implements BookmarksState {
  const factory BookmarksLoadError() = _$BookmarksLoadError;
}

/// @nodoc
abstract class $BookmarksClearInProgressCopyWith<$Res> {
  factory $BookmarksClearInProgressCopyWith(
          BookmarksClearInProgress value, $Res Function(BookmarksClearInProgress) then) =
      _$BookmarksClearInProgressCopyWithImpl<$Res>;
}

/// @nodoc
class _$BookmarksClearInProgressCopyWithImpl<$Res> extends _$BookmarksStateCopyWithImpl<$Res>
    implements $BookmarksClearInProgressCopyWith<$Res> {
  _$BookmarksClearInProgressCopyWithImpl(BookmarksClearInProgress _value, $Res Function(BookmarksClearInProgress) _then)
      : super(_value, (v) => _then(v as BookmarksClearInProgress));

  @override
  BookmarksClearInProgress get _value => super._value as BookmarksClearInProgress;
}

/// @nodoc
class _$BookmarksClearInProgress implements BookmarksClearInProgress {
  const _$BookmarksClearInProgress();

  @override
  String toString() {
    return 'BookmarksState.bookmarksClearInProgress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is BookmarksClearInProgress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bookmarksInitial,
    required TResult Function(List<Thread> threads, bool isLastPage) bookmarksLoadSuccess,
    required TResult Function() bookmarksLoadError,
    required TResult Function() bookmarksClearInProgress,
    required TResult Function() bookmarksIsEmpty,
  }) {
    return bookmarksClearInProgress();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bookmarksInitial,
    TResult Function(List<Thread> threads, bool isLastPage)? bookmarksLoadSuccess,
    TResult Function()? bookmarksLoadError,
    TResult Function()? bookmarksClearInProgress,
    TResult Function()? bookmarksIsEmpty,
    required TResult orElse(),
  }) {
    if (bookmarksClearInProgress != null) {
      return bookmarksClearInProgress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookmarksInitial value) bookmarksInitial,
    required TResult Function(BookmarksLoadSuccess value) bookmarksLoadSuccess,
    required TResult Function(BookmarksLoadError value) bookmarksLoadError,
    required TResult Function(BookmarksClearInProgress value) bookmarksClearInProgress,
    required TResult Function(BookmarksIsEmpty value) bookmarksIsEmpty,
  }) {
    return bookmarksClearInProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookmarksInitial value)? bookmarksInitial,
    TResult Function(BookmarksLoadSuccess value)? bookmarksLoadSuccess,
    TResult Function(BookmarksLoadError value)? bookmarksLoadError,
    TResult Function(BookmarksClearInProgress value)? bookmarksClearInProgress,
    TResult Function(BookmarksIsEmpty value)? bookmarksIsEmpty,
    required TResult orElse(),
  }) {
    if (bookmarksClearInProgress != null) {
      return bookmarksClearInProgress(this);
    }
    return orElse();
  }
}

abstract class BookmarksClearInProgress implements BookmarksState {
  const factory BookmarksClearInProgress() = _$BookmarksClearInProgress;
}

/// @nodoc
abstract class $BookmarksIsEmptyCopyWith<$Res> {
  factory $BookmarksIsEmptyCopyWith(BookmarksIsEmpty value, $Res Function(BookmarksIsEmpty) then) =
      _$BookmarksIsEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class _$BookmarksIsEmptyCopyWithImpl<$Res> extends _$BookmarksStateCopyWithImpl<$Res>
    implements $BookmarksIsEmptyCopyWith<$Res> {
  _$BookmarksIsEmptyCopyWithImpl(BookmarksIsEmpty _value, $Res Function(BookmarksIsEmpty) _then)
      : super(_value, (v) => _then(v as BookmarksIsEmpty));

  @override
  BookmarksIsEmpty get _value => super._value as BookmarksIsEmpty;
}

/// @nodoc
class _$BookmarksIsEmpty implements BookmarksIsEmpty {
  const _$BookmarksIsEmpty();

  @override
  String toString() {
    return 'BookmarksState.bookmarksIsEmpty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is BookmarksIsEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bookmarksInitial,
    required TResult Function(List<Thread> threads, bool isLastPage) bookmarksLoadSuccess,
    required TResult Function() bookmarksLoadError,
    required TResult Function() bookmarksClearInProgress,
    required TResult Function() bookmarksIsEmpty,
  }) {
    return bookmarksIsEmpty();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bookmarksInitial,
    TResult Function(List<Thread> threads, bool isLastPage)? bookmarksLoadSuccess,
    TResult Function()? bookmarksLoadError,
    TResult Function()? bookmarksClearInProgress,
    TResult Function()? bookmarksIsEmpty,
    required TResult orElse(),
  }) {
    if (bookmarksIsEmpty != null) {
      return bookmarksIsEmpty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BookmarksInitial value) bookmarksInitial,
    required TResult Function(BookmarksLoadSuccess value) bookmarksLoadSuccess,
    required TResult Function(BookmarksLoadError value) bookmarksLoadError,
    required TResult Function(BookmarksClearInProgress value) bookmarksClearInProgress,
    required TResult Function(BookmarksIsEmpty value) bookmarksIsEmpty,
  }) {
    return bookmarksIsEmpty(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BookmarksInitial value)? bookmarksInitial,
    TResult Function(BookmarksLoadSuccess value)? bookmarksLoadSuccess,
    TResult Function(BookmarksLoadError value)? bookmarksLoadError,
    TResult Function(BookmarksClearInProgress value)? bookmarksClearInProgress,
    TResult Function(BookmarksIsEmpty value)? bookmarksIsEmpty,
    required TResult orElse(),
  }) {
    if (bookmarksIsEmpty != null) {
      return bookmarksIsEmpty(this);
    }
    return orElse();
  }
}

abstract class BookmarksIsEmpty implements BookmarksState {
  const factory BookmarksIsEmpty() = _$BookmarksIsEmpty;
}
